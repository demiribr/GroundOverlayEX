Defines primary javascript classes:  GroundOverlayEx, GroundOverlayEX_mgr, LatLngQuad, ZoomArray, ZoomEntryZoom, ZoomEntryAlt_ft, ZoomEntryAlt_m
Classes are extended from google.maps.OverlayView (GroundOverlayEx) and google.maps.MVCObject (all the rest)
Libraries needed:  (javascript) Google Maps API V3, Numeric.js
Version 1.42
Attribution: Mike Maschino, Google Maps API
License: MIT License (see License.txt file)

Concepts of Operation:
1.  The GroundOverlayEX class can be used "stand-alone" alongside other Google Maps features, including 
    regular GroundOverlay objects.  A minimal set of constructor information to a GroundOverlayEX object will 
    display the image like any other GroundOverlay, but also providing cropping, rotation, and/or non-rectangular 
    transforms that the regular GroundOverlay class cannot provide.
2.  To gain functionality more like Google Earth, numerous GroundOverlayEx objects can be instanciated and placed
    under the management of a GroundOverlayEX_mgr object.  The manager will dynamically display or not display
    images from the GOEXs it manages based upon the current map viewport latitudes and longitudes.  Thus hundreds
    or thousands of GOEXs could be defined and loaded into the manager, but the map and the browser will only need to
    handle a limited number of images that should be presently showing given the map position and zoom.  The manager
    is particular needed for handling a huge quantities of GOEXs, or for handling a large quantity of very large 
    high-resolution images.  When under management, the GOEXs that are actively displaying are participating in 
    the Google Maps environment.
3.  A single instance of the GroundOverlayEX class can be used for a javascript-based geographic-related image editing: placement, size, rotation, transformation
    
Data types used:  all the google.maps data types (e.g. LatLng, LatLngBounds)
New data types:	  LatLngQuad, zoomArray, zoomEntryZoom, zoomEntryAlt_ft, zoomEntryAlt_m

It is strongly suggested to understand the KML definition of GroundOverlay (plus Google's extensions);
this class provides nearly all the capabilities as the KML GroundOverlay object
https://developers.google.com/kml/documentation/kmlreference#groundoverlay

There are two javascript files:
	groundoverlayEX.js		- supports all capabilities except editing (and therefore takes up less browser RAM per-object)
	groundoverlayEXeditable.js	- supports all capabilities including editing

================
LatLngQuad class
================
A LatLngQuad constructs a non-rectangular convex quadrilateral in geographical coordinates for tilt distorted 
ground overlay images.  It defines the geographical coordinates of the original four corners of an image in 
a specific order:  Bottom-Left, Bottom-Right, Top-Right, and Top-Left.  Note that for example Bottom-Left does not
correspond to South-West; the geographic coordinates may rotate, resize, and non-rectangularly distort the image.

Extends from class: google.maps.MVCObject	
Constructor:					Returns			  Description
------------					-------			  -----------
LatLngQuad(google.maps.LatLng:bottom_Left, 
           google.maps.LatLng:bottom_Right, 
           google.maps.LatLng:top_Right, 
           google.maps.LatLng:top_Left)         Object			  Constructor

Methods:
--------
.destroy()                                      none                      release all internally stored objects
.clone()                                 	LatLngQuad  		  returns a new object that is a clone of the current LatLngQuad object
.isEmpty()                                      Boolean                   true=the object had a properly passed parameters
.getBottomLeft()                                google.maps.LatLng        returns what was passed in the constructor
.getBottomRight()                               google.maps.LatLng        returns what was passed in the constructor
.getTopRight()                                  google.maps.LatLng        returns what was passed in the constructor
.getTopLeft()                                   google.maps.LatLng        returns what was passed in the constructor
.getNorthMost()                                 Number                    returns the northmost latitude from all four corners; this is the maximum of the latitudes
.getSouthMost()                                 Number                    returns the southmost latitude from all four corners; this is the minimum of the latitudes
.getEastMost()                                  Number                    returns the eastmost longitude from all four corners; this is the maximum of the longitudes
.getWestMost()                                  Number                    returns the westmost longitude from all four corners; this is the minimum of the longitudes
.getBoundsBox()                                 google.maps.LatLngBounds  returns a bounds composed of the {southmost,westmost} and the {northmost,eastmost}
.toSpan()                                       google.maps.LatLng        returns the linear size in geographic coordinates of the BoundsBox
.getPosition()					google.maps.LatLng	  returns the center of the BoundsBox
.getCenter()                                    google.maps.LatLng        returns the true center (intersect of bimedians) latitude and longitude of the convex quadrilateral
.inBoundsBox(google.maps.LatLng:position)       Boolean                   true=the passed LatLng position is inside the BoundsBox (suitable only for Region checking)
.toString()                                     String                    returns a human-readable string of the four corner geographic coordinates in constructor order
.toUrlValue(Number:precision)                   String                    returns a sequence of eight comma-delimited values of the latitudes and longitudes of the corners in constructor order; precision if specified will limit the factional portion to only the indicated number of digits

Code Example:
-------------
var bl = new google.maps.LatLng(..., ...);
var br = new google.maps.LatLng(..., ...);
var tr = new google.maps.LatLng(..., ...);
var tl = new google.maps.LatLng(..., ...);
var llq = new google.maps.LatLngQuad(bl, br, tr, tl);


===============
zoomArray class
===============
This class stores a series of zoom ranges with corresponding image URL to display.  Alternatively, Google Earth camera viewpoint altitudes in either feet or meters above
sea level can specified.  Although these types of entries can be intermixed, this is not recommended.  whichever entry that first matches the Google Maps V3 zoom level
will be selected; other possibly relevent entries will be ignored.

Constructor:					Returns			Description
------------					-------			-----------
ZoomArray();					Object			Constructor

Methods:
--------
.destroy()					none			release all internally stored objects
.length()					Number			returns quantity of entries that have been added
.addZoomEntry(zoomEntry*:entryToAdd)		none			add a new zoomEntry* to the end of the array
.prependZoomEntry(zoomEntry*:entryToInsert)	none			add a new zoomEntry* to the beginning of the array
.getUrl(Number:indexNo)				String			returns the URL of the passed index number
.whichIndexPerUrl(String:Url)			Number			returns the index number of which first entry has the specified URL; -1=no such entry found
.whichIndexPerZoom(Number:zoom)			Number			returns the index number of which first entry is applicable for the specified zoom level number; -1=no such entry found

==================
zoomEntry* classes
==================
This class specifies a range of zoom levels or altitudes with an image URL.

Extends from class: google.maps.MVCObject
Constructors:												Returns
-------------												-------
zoomEntryZoom(Number:lowerZoom, Number:higherZoom, String:imageURL)					Object
zoomEntryAlt_ft(Number:lowerAltitude_feet, Number:higherAltitude_feet, String:imageURL)			Object
zoomEntryAlt_m(Number:lowerAltitude_meters, Number:higherAltitude_meters, String:imageURL)		Object

Methods:
--------
none externally available

Code Example:
-------------
var za = new ZoomArray();
var ze1 = new ZoomEntryZoom(0, 8, "http://somewhere.com/image1.jpg");
za.addZoomEntry(ze1);
var ze2 = new ZoomEntryZoom(9, 22, "http://somewhere.com/image1_highrez.jpg");
za.addZoomEntry(ze2);


=====================
GroundOverlayEX class
=====================
This class displays a rectangular (with rotation) or non-rectangular image overlay on the map.  The image can also be pre-cropped.  This GroundOverlay class implements
most of the capabilities of a KML-defined GroundOverlay.  However, level-of-detail works differently, and this GroundOverlayEx class can manage multiple versions of 
the same image at different proportional sizes and resolutions.

Extends from class: google.maps.OverlayView
Constructor:						Returns
------------						-------
GroundOverlayEX(String:url, 
		google.maps.LatLngBounds:boundsBox, 
		Object:GroundOverlayEX_options)		Object

Passed Parameter Notes:
-----------------------
  url:  should always be passed (and entered into a ZoomArray if being used); if cropping, then this should be the URL for the image which the cropping parameters apply to
  boundsBox:  for a LatLngBounds-mode ground overlay, a LatLngBounds must be provided; for a LatLngQuad-mode ground overlay, this should be null ... if both a LatLngQuad and a LatLngBounds are provided, the LatLngBounds will be ignored
  
Supports GroundOverlayOptions:			Default	Description
------------------------------			-------	-----------
  opacity: Number,				1	number ranging from zero (transparent) to one (fully opaque) to be applied to the displayed image
  map: google.maps.Map,				null	auto-loads the google.maps.MAP; if not specified then the application must invoke the .setMap() method prior to using the GroundOverlayEX object
  clickable: Boolean,				false	true=pass-thru various click and mouse events for the application to listen to

Supports GroundOverlayEX_options:		Default	Description
---------------------------------		-------	-----------
  clickableAtZoom: Number,			0	specifies at which zoom level or higher that clickable events start to be listened for
  clickableEvents: String,			"all"	specifies which events are wanted: "all","click","dblclick","rightclick","mouseover","mouseout","mousedown","mouseup"
  rotate: Number,				0	specifies the rotation to be applied to the image only in latlngBounds mode; ignored if a LatLngQuad is specified; degrees counter-clockwise
  origImgWidth: Number,				0	if specified, this must be the original image width of the image passed in url (on which the crop values below are based); see cropping and event notes below
  origImgHeight: Number,			0	if specified, this must be the original image height of the image passed in url (on which the crop values below are based); see cropping and event notes below
  cropFromLeft: Number,				0	if specified, first crop the image passed in url from the left the number of indicated pixels; see cropping notes below
  cropToWidth: Number,				0	if specified, second crop the resultant width to the indicated pixels; see cropping notes below
  cropFromBottom: Number,			0	if specified, first crop the image passed in url from the bottom the number of indicated pixels; see cropping notes below
  cropToHeight: Number,				0	if specified, second crop the resultant height to the indicated pixels; see cropping notes below
  latlngQuad: LatLngQuad,			null	specifies the LatLngQuad to use to display the GroundOverlayEX images; overrides any latlngBox passed parameter
  id: String,					""	optional application-defined identity string for the GroundOverlayEX object; only used by the application
  displayText: String,				""	optional string of information associated with the groundoverlay; can be used for a google.maps.InfoWindow; only used by the application
  zoomArray: ZoomArray,				null	specifies a set of image URLs to display at different map zoom levels; if not specified then the url passed parameter will be used at all zoom levels
  regionBounds: google.maps.LatLngBounds,	null	specifies a region bounds if which is visible in any portion on the map viewport, the GroundOverlayEX will load the proper image for the zoom and display it
  drawOrder: Number,				0	specifies a layered drawing order number in cases where ground overlay images overlap; if not specified then zero is used
  zIndexBase: Number,				1000	the drawOrder is added to this zIndexBase for layering in the browser; if not specified then a default zIndexBase is used
  zIndex: Number,				0	a specific zIndex to use instead of zIndexBase+drawOrder; if specified then the other two are ignored
  editable: Boolean				false	true=potentially allow the image to be edited (a control-rightclick on the image will activate editing or it can be done programatically; false=no editing allowed; see the Editing section at the end of this document

Extended Properties:		Returns				Description
--------------------		-------				-----------
.position			LatLng				a fast and approximate center LatLng suitable for InfoWindows, Markers, or other Google Map uses

Standard Methods:
-----------------						
.getBounds()			google.maps.LatLngBounds	returns the current LatLngBounds for the image; null=none available; after editing, this will reflect the new LatLngBounds of the edited image (if .displayMode() == 'B')
.getUrl()			String				returns the url passed parameter (and not any of the zoomArray URLs)
.getOpacity()			Number				(see the Google Maps API V3 definitions for a GroundOverlay)
.setOpacity(Number:opacity)	none				(see the Google Maps API V3 definitions for a GroundOverlay)

Map Framework methods:
----------------------						
.onAdd()			none				(see the Google Maps API V3 definitions for an OverlayView)
.draw()				none				ditto
.onRemove()			none				ditto
.getMap()			google.maps.Map			ditto
.getProjection()		google.maps.MapCanvasProjection ditto
.getPanes()			google.maps.MapPanes		ditto
.setMap(google.maps.Map:map)	none				ditto - note: this MUST be set before the GroundOverlayEX object will perform any actions

Extended Methods:
-----------------
.getVersion()			String				returns the version code of the GroundOverlayEX class

.destroy()			none				completely destroy the object's internal data; object cannot be re-activated using .setMap(map)
.getId()			String				gets the application-defined id for the Object; the Object only uses this to display any errors on the console log
.getDisplayText()		String				gets the application-defined string for the Object; the Object does not use this string at all
.setDisplayText(String:text)	none				sets the application-defined string for the Object; the Object does not use this string at all
.getPosition()			google.maps.LatLng		returns a fast and approximate center LatLng suitable for InfoWindows, Markers, or other Google Map uses; after editing, this will reflect the new position of the edited image
.getCenter()			google.maps.LatLng		returns a center LatLng for the image, including computed bimedians center of a non-rectangular image; after editing, this will reflect the new center of the edited image
.getOverCropped()		Boolean				returns true=cropping parameters are too large and likely made image invisible; false=image is properly cropped or there was no cropping specified
.getDisplayMode()		String				returns which geographic coordinates are being used: 'B'=LatLngBounds, 'Q'=LatLngQuad
.getBoundsOriginal()		google.maps.LatLngBounds	returns the LatLngBounds which was passed in the constructor; could be null
.getLatLngQuadType()		String				returns the source of the LatLngQuad information: 'R'=approximated from the LatLngBounds-mode image corners, 'N'=measured from the LatLngQuad-mode image corners
.getLatLngQuad()		LatLngQuad			returns the current LatLngQuad for the image; null=none available; after editing, this will reflect the new LatLngQuad of the edited image (if .displayMode() == 'Q')
.getLatLngQuadOriginal()	LatLngQuad			returns the LatLngQuad which was passed in the constructor; could be null
.getRegionBounds()		google.maps.LatLngBounds	returns the LatLngQuad for the region bounds in-use by the GroundOverlayEX; could be the region provided in the constructor; or if not provided then it will have been computed by the GroundOverlayEX class
.getRotation()			Number				returns the rotation applied to the image only in latlngBounds mode; after editing, this will reflect the new rotation of the edited image
.getDrawOrder()			Number				returns the current draw order value
.setDrawOrder(Number:drawOrder)	none				sets a draw order value, and image will change zIndex order; must be >= 0
.getZindexBase()		Number				returns the application defined zIndexBase; 0=none set and the internal default is being used
.setZindexBase(Number:zIndex)	none				set the application defined zIndexBase, and image will change zIndex order; must be > 0; 0 = use default
.getZindex()			Number				get the override zIndex value; if > 0 then drawOrder and ZindexBase are ignored
.setZindex(Number:zIndex)	none				set the override zIndex value, and image will change zIndex order; if > 0 then drawOrder and ZindexBase are ignored
.getEffectiveZindex()		Number				returns the zIndex in-use by the GroundOverlayEX object regardless of how it was calculated
.supportsEditing()		Boolean				return: true=this javascript class file includes the editing capabilities; false=this javascript class file cannot perform editing

Display Mode Notes:
-------------------
Just like the KML defintion of a GroundOverlay, there are two possible display modes in the GroundOverlayEX.  Only one may be active.  If information is provided
in the constructor for both a LatLngQuad and a LatLngBounds, the LatLngBounds and rotation will be ignored.  During optional editing, it is possible to change a
LatLngBounds mode into a LatLngQuad mode by doing corner dragging; this change cannot be reversed.
	Mode		.displayMode() value	Description
	----		--------------------	-----------
	LatLngBounds	B			A rectangle where the top-right of the image gets placed by the north-east bound, and the bottom-left of the image
						gets placed by the south-west bound.  That placement may resize the images width and height, even non-proportionally.
						Finally the image may optionally be rotated about its center.
	LatLngQuad	Q			Latitude,Longitude pairs for each of the four corners of the image.  These pairs can resize, rotate, skew, and
						transform the image into non-rectangular shapes (suitable for correcting tilt distortion in the image).  The order of
						the pairs must be for the following corners in order:  Bottom-left, Bottom-right, Top-right, Top-left


Internal Order-of-Operation Notes:
----------------------------------
A GroundOverlayEX object passes through various stages and states depending on where it is placed in relation to the currently viewed map viewport
	1.  GroundOverlayEX Object is constructed; missing information such as RegionBounds is automatically created
	2.  The Object is added to the Google Map
	3.  The Object assesses whether its RegionBounds is viewable:
		if not, then the Object waits until it is visible
	4.  The Object assesses the current map zoom level, and chooses the appropriate image
	5.  If the needed image is not yet loaded, the Object initiates download of the image then waits
	6.  The now-downloaded image is cropped if supposed to be
	7.  If in LatLngBounds mode, the image is rotated; if in LatLngQuad mode, the image is transformed
	8.  The image is added to the Google Map and now gets displayed
	9.  The Object waits and listens to the map
	10. If the map viewport changes for any reason, the Object assesses whether its RegionBounds are still in display view:
		If out-of-view, the image is removed from the Google Map but remains loaded, then go to step 9 and wait
		if in-view, the Object assesses whether the zoom level changed or not:
			if zoom is the same, then nothing need be done; go to step 9 and wait
			if zoom has changed, then go to step 4 above
This order of operation helps reduce burden on the Google Map when hundreds or thousands of GroundOverlayEX objects are instanciated.  Only those images that
actively need display are placed into the map's management.  If the GroundOverlayEX Object has images that are loaded but not-displayed, after a period of
time of non-display the Object will also unload the images, which reduces memory and burden on the browser.  These features are provided to ensure the
Google Map remains quick and responsive for the average end-user on an average (non-mobile) computer.  

The application developer has the option to widen the passed RegionBounds such that it is larger than the image's natural LatLngBounds or 
LatLngQuad's BoundingBox.  THis will have the effect of pre-loading and pre-displaying images that are very near to the viewport and very likely to be 
displayed soon by the end-user.  Use of the optional GroundOverlayEX_mgr class can provide a more effective means to accomplish that for a large number
of GroundOverlayEX objects.


ZoomArray instead of Level-of-Detail
------------------------------------
The KML specification forces the creation of many times the quantity of GroundOverlay objects when there are several available resolutions of the same image, and
uses a Level-of-Detail upper and lower limit to choose which to show and which to hide.  Rather than over-burdening Google Maps on the browser with this, the 
GroundOverlayEX uses an alternate method to accomplish this more effectively for Google Maps.  A ZoomArray is a simple structure that allows the application
developer to associate an image's per-resolution URL with a range of Google Maps zoom levels.  A trivial example is:

Code Example:
	var za = new ZoomArray();
	var ze1 = new ZoomEntryZoom(0, 8, "http://somewhere.com/image1.jpg");
	za.addZoomEntry(ze1);
	var ze2 = new ZoomEntryZoom(9, 22, "http://somewhere.com/image1_highrez.jpg");
	za.addZoomEntry(ze2);
	var goex = new GroundOverlayEX("http://somewhere.com/image1_highrez.jpg", bnds, { zoomArray: za, map: map });

This allows just one GroundOVerlayEX object to manage all the per-resolution image URLs, instead of two or three or more objects just to show the same image at different
resolutions.  The cropping parameters (if specified) will be applied proportionally to all other resolutions (see the cropping notes below).

Note that each image URL placed into the ZoomArray must be the same image, just a smaller or larger proportional version in terms of size and resolution.  If the imagery
is of entirely larger or smaller regions at different resolution levels (a typical case for image tiling), then multiple GroundOverayEX objects would still have to be used.
Indeed, use of GroundOverlay or GroundOverlayEX are not recommended for image tiling. 

If the application's data has "camera"/"point-of-view" altitude data instead, there are ZoomEntryAlt_ft and ZoomEntryAlt_m available as well that will compute the 
zoom levels based upon passed point-of-view altitude ranges.

When using a ZoomArray, it is strongly recommended to pass the "OrigImgWidth" and "OrigImgHeight" values in the configuration options, especially when using either
Cropping or listening to events.  The "OrigImgWidth" and "OrigImgHeight" must be for the image passed in the url parameter, and is the context that will be used for
event generation and cropping.


Cropping Notes:
---------------
Image pre-cropping is done in a similar manner as the Icon <gx:x>,<gx:y>,<gx:w>,<gx:h> subfields in the KML specification.  Note the KML defines an image origin 
as the *Bottom-Left* of the image; browsers use the Top-Left.  Hence the crop parameters for horizontal are defined as "cropFromBottom" and "cropToHeight".

When using a ZoomArray, the cropping parameters that are specified need to be for the particular image size and resolution of the image passed in the url parameter.

The two additional yet optional passed cropping parameters "OrigImgWidth" and "OrigImgHeight" are available to help reduce broswer computing load in 
certain circumstances.  Again "OrigImgWidth" and "OrigImgHeight" must be for the image passed in the url parameter.  The code snippet below shows the 
scenario where these two additional parameters are useful:

Code Example:
	(assume variables 'map' and 'bnds' have been properly defined, that the map is currently at zoom level 5, 
	 that image1.jpg is 512x512, and image1_highrez.jpg is 512000x512000)

	var za = new ZoomArray();
	var ze1 = new ZoomEntryZoom(0, 8, "http://somewhere.com/image1.jpg");
	za.addZoomEntry(ze1);
	var ze2 = new ZoomEntryZoom(9, 22, "http://somewhere.com/image1_highrez.jpg");
	za.addZoomEntry(ze2);
	var goex = new GroundOverlayEX("http://somewhere.com/image1_highrez.jpg", bnds, { zoomArray: za, map: map, cropFromLeft: 100000 });


Following the Internal Order-of-Operation, step 4 chooses the much smaller "http://somewhere.com/image1.jpg".  However, at step 6, the passed crop 
parameters are for the much larger "http://somewhere.com/image1_highrez.jpg".  But the GroundOverlayEX object does not yet know that larger image's width and 
height, and cannot therefore proportionally adjust the crop parameter down to the smaller image's size.  The GroundOverlayEX object is forced to download BOTH 
images (and wait till BOTH get completely downloaded), then it has sufficient information about the larger image to crop the smaller image.  Although this is 
not a big deal for one individual GroundOverlayEX object, if there are hundreds or thousands then alot of extra downloading and wasted time is spent, when the 
Object was designed to attempt to minimize that.

So for enhanced performance, when a ZoomArray for a GroundOverlayEX object, it is optimal to also provide the "OrigImgWidth" and "OrigImgHeight".
Alot less image downloads will occur.  If a GroundOverlayEX object is cropping but will not be using a ZoomArray, providing or not providing those two parameters 
does not impact performance either way.


RegionBounds and GroundOverlayEX_mgr Notes:
-------------------------------------------
As indicated above, RegionBOunds is used in step 3 and step 10 of the Internal Order-of-Operation.  Since this bounds is very important to the Object, if it is 
not passed in the constructor, then the Object computes it as follows:

	Mode		.displayMode() value	If RegionBounds was not provided:
	----		--------------------	---------------------------------
	LatLngBounds	B			RegionBounds is set equal to passed parameter LatLngBounds
	LatLngQuad	Q			RegionBounds is set equal to passed parameter LatLngQuad.getBoundsBox()

The default computation of the region ensures that the moment it becomes visible on the map viewport, the proper image is indeed loaded and displayed.  However,
this could cause pauses when zooming and panning as especially large images from slow servers are downloaded.  The application developer should choose to pass
an expanded RegionBounds than those defaults above.  Doing so would cause images that are near to the viewport to be pre-download and pre-displayed even 
though still off-screen.  This could of-course impact performance, so use that option with care.

As has been mentioned (and will be detailed below), an optional GroundOverlayEX_mgr class is available.  This class allows the application developer to place
all the GroundOverlayEX objects into the manager object.  One task of the manager object is to add and remove the GroundOverlayEX objects from the map framework
itself, which is useful when one may have thousands of defined GroundOverlayEX objects, yet do not want to over-burden the map framework with so many 
feature objects.  A portion of that functionality is to also evaluate which GroundOverlayEX objects are *near* the viewport, yet are off-screen, but should be 
pre-added to the map and pre-loaded to provide a smoother end-user experience.  Each GroundOverlayEX's RegionBounds are used in that evaluation, but against wider
viewport contexts.

The end result is that pre-loading can be achieved with the manager class without having to compute widened RegionBounds, and indeed the default internally 
computed RegionBounds can be used, but still have controlled pre-loading capabilities.


Events Notes:
-------------
The GroundOverlayEX class itself captures selected map events and events concerning its displayed image.  This is especially true during editing mode.
However, the application developer can listen to events from the GroundOverlayEX object itself.  If the passed parameter "clickable" is set to true,
the object will pass-thru and trigger the following events when they occur (including the MouseEvent data).  Note the use of addListener instead of
addDomListener: the GroundOverlayEX object itself is not subject to DOM events (its not "drawn" onto the web page; just the internally stored images are "drawn" 
onto the web page).  The applicable GroundOverlayEx object is provided also as a second passed parameter, with additional four parameters of clicked on imageX
point, imageY point, latitude, longitude:
	
Available DOM Events:
	click, dblclick, rightclick, mouseover, mouseout, mousedown, mouseup

Code example:
	:
	var goex = new GroundOverlayEX( ..., ..., { ..., clickable: true});
	var listener = google.maps.event.addListener(goex, "rightclick", function(mouseEvent, theGoex, imageX, imageY, lat, lon) { ... });

The ImageX and imageY are expressed in values relative to the *cropped* size of the image passed in the url parameter (regardless of which actual image is presently 
being shown).  So like cropping, if a ZoomArray has been defined and if the application developer does not pass in the "OrigImgWidth" and "OrigImgHeight" values,
then the GroundOverlayEX object may be forced to also download the url passed parameter image file.  If ImageX and ImageY are returned as -1, then the
GroundOverlayEX could not calculate the proper values.  However, the mouseEvent class itself has various useful X,Y points:  screen, page, client, and layer. 
The mouseEvent.layerX and mouseEvent.layerY are the point-on-the-image, however for the size of the image currently shown via the ZoomArray.

There are some oddities about the DOM events.  
1. Double-clicking on an image will generate two "click" events then one "doubleclick" event.  This class passes them through as-is.
2. When dragging the map, if the mousedown is on a GroundOverlayEX image, a "click" event gets generated even though a drag should not count as a click.
   The GroundOverlayEX detects this and will not generate a "click" event if the reason for the mousedown & mouseup was to drag the map.
3. The Google Maps framework does not appear to actually pass-through "rightclick" actions on the GroundOverlayEX's images; the GroundOverlayEX class however needs to
   detect rightclicks for editing, and will as a courtesy generate a "rightclick" event to the application.

If there are hundreds or thousands of GroundOverlayEX objects, and say the map zoom level is at 0 or 1 such that ALL of the overlays are being shown,
that is alot of handlers the map framework has to deal with.  Usually at lower zoom levels, one really does not want to show popups or click-for-infoWindow.
So the "clickableAtZoom" and "clickableEvents" constructor options all the developer to minimize the listeners to 1) those only needed, and 2) to only when
they are applicable at a minimum zoom level.

Using the GroundOverlayEX_mgr class also helps reduce the number of listeners that the map framework must deal with.  See the Events Notes section of that 
class for more information.


Editing Notes:
--------------
See the final section of this document on use of the GroundOverlayEX in a geolocation web-app, or for in-line editing on a map.


=========================
GroundOverlayEX_mgr class
=========================
This class functions as a high level manager for a large quantity of GroundOverlayEX objects.  The manager only places those GroundOverlayEX objects onto the
Google Map framework that are nearby or within the current map viewport.  It can also do mass changes to all GroundOverlayEX objects that it is managing, such
as changing the Opacity of all the GroundOverlayEX object.

Extends from class: google.maps.MVCObject
Constructor:									Returns
------------									-------
GroundOverlayEX_mgr(google.maps.Map:map, GroundOverlayEX_mgr_options)		Object

Passed Parameter Notes:
-----------------------
  map:  google.maps.Map to be used for all the managed GroundOverlayEXs

GroundOverlayEX_mgr_options:		Default			Description
----------------------------		-------			-----------
  placementRegion: String,		zoom2x			see notes below on expanded region bounds; acceptable values: zoom2x
  preloadRegion: Number			0			see notes below on expanded region bounds; acceptable values: 0=off to 1=placementRegion

Methods:				Returns			Description
--------				-------			-----------
.destroy()				none			deletes all GOEXs, terminates all operations, and releases all memory objects
.getVersion()				String			returns the version code of the GroundOverlayEX_mgr class

.getMap()				google.maps.Map		(see the Google Maps API V3 definitions for a GroundOverlay)
.supportsEditing()			Boolean			return: true=this javascript class file includes the editing capabilities; false=this javascript class file cannot perform editing
.addGOEX(GroundOverlayEX)		Boolean			true=add was successful; currently the only reason for rejection is that the GroundOverlayEX does not have a RegionBounds defined or calculated
.startOfBulkload()			none			indicates the start of a bulk load process of many GOEXs
.addGOEXbulkload(GroundOverlayEX)	Boolean			one of a large bulk to GOEXs being added; when bulk loading, PreloadRegion is ignored until [.endOfBulkload() is called to help reduce simultaneous download of imagery]
.endOfBulkload()			none			indicates the end of bulk loading
.setAllOpacity(Number)			none			changes the opacity of every GroundOverlayEX object being managed
.getPlacementRegion)			String			see notes below on expanded region bounds; acceptable values: zoom2x
.setPlacementRegion(String)		none			see notes below on expanded region bounds; acceptable values: zoom2x
.getPreloadRegion()			Number			see notes below on expanded region bounds; acceptable values: 0=off to 1=zoom2x
.setPreloadRegion(Number)		none			see notes below on expanded region bounds; acceptable values: 0=off to 1=zoom2x
.getAllQtys()				Array:Numbers		returns sums of quantities across all the GOEXs; may be useful during application debugging:
									[0]=qty GOEXs under management, [1]=qty GOEXs added to map, [2]=qty Event Listeners allocated,
									[3]=qty images being downloaded, [4]=qty images successfully downloaded, [5]=sum loaded image pixel sizes (width * height), 
									[6]=qty of recent image download retries, [7]=qty of display elements, [8]=qty being displayed

Code example:
-------------
	var goexMgr = new GroundOverlayEX_mgr(map);
	:
	var goex = new GroundOverlayEX( ..., ..., { ...});
	var success = goexMgr.addGoex(goex);


Expanded RegionBounds Notes
---------------------------
The manager's primary function is to unload and load GroundOverlayEX's from the Google map.  This is really only necessary for large or huge numbers of 
GroundOverlayEX objects to keep the Google Maps framework from getting overloaded and unresponsive.  The manager does this by defining a "super viewport" 
based upon the map's currently displayed viewport.  All GroundOverlayEX objects with any portion of their RegionBounds inside this super viewport 
are loaded into the Google Map (meaning their .setMap(map) is called).  All other GroundOverlayEX objects are removed from the map (meaning a .setMap(null) 
is called).  That super viewport is called the "placementRegion".

The manager currently offers one definition for that placement region named "zoom2x".  The placement region is what would be showing on the map if the zoom 
was reduced one level (which in Google Maps means two times width and height of what is being shown).  So effectively the manager keeps within Google Maps
all those GroundOverlayEX objects that would be visible if the end-user zoomed out one level.

Each GroundOverlayEX object that IS loaded into the Google Map makes its own assessment of whether to load the proper image for the zoom and display it based upon 
its local decision about its RegionBounds and the current map viewport.  So normally, all those extra GroundOverlayEX objects that got loaded into the surrounding 
off-screen space remain idle and in particular do not attempt to pre-load their images.

Using the manager, the application developer can also activate the "preloadRegion".  This region is typically between the "placementRegion" and the current map 
viewport region.  All GroundOverlayEX objects that are inside the preloadRegion (but are not yet visible on the viewport) are instructed by the manager to preload 
their proper image for the zoom, but not yet display it.  Then when the end-user drags or pans the map, the GroundOverlayEX objects that suddenly come into view
already have downloaded their images, and instantaneously display them.

The preloadRegion is a value between 0 and 1.  0 means no preloadRegion.  1 means the preloadRegion is the same size as the placementRegion.  values in-between are
mid-points between the current map viewport size and the preloadRegion.  For example, .5 means the preloadRegion is half-way between the map viewport and the 
placementRegion; .25 means just quarter-way from the viewport to the placementRegion, etc.

If many GOEX's are loaded into the manager class simultaneously at the first initialization of a map, with a preloadRegion defined, some browsers (particularly
Firefox) get image download errors.  To help mitigate this problem with the browser, some recommendations:
1.  Start out at a mid-range zoom level or higher ... don't start out with zoom levels 0 to 5.
2.  Use the .startOfBulkload(), .addGOEXbulkload, and .endOfBulkload methods to bulk load at map initialization.  The preloadRegion will temporarily be 
	ignored, reducing the number of images initially downloaded in bulk.  It is recommended to even use a setTimeout() to call the .endOfBulkload() method
	after say 5 or so seconds to allow the visible images to download first.  See the code example below.

Events Notes:
-------------
In order to reduce load on the map framework when hundreds or thousands of GroundOverlayEX objects are being displayed at maximum zoomout, the GroundOverlayEX_mgr 
class can act as an aggregator for clickable events that happen from the GroundOverlayEX objects that it manages.  If managed GroundOverlayEX 
obects are set as "clickable: true" in their constructor (and optionally have their "clickableAtZoom" and "clickableEvents" also set), those objects also trigger events 
as the GroundOverlayEX_mgr object (*without* using Google Maps events listeners and triggers).  The application need only listen to  the manager, not all the individual
GroundOverlayEX objects, as also shown in the code example below.

Code example: cropping not shown in this example; show low-resolution image at zoom levels 0 thru 8
-------------
	:
	:
	var goexMgr = new GroundOverlayEX_mgr(map);
	google.maps.event.addListener(goexMgr, "dblclick", function(mouseEvt, theGOEX, imageX, imageY, lat, lon){ a_GOEX_was_doubleclicked(theGOEX, mouseEvt, imageX, imageY, lat, lon); });

	:
	: setup a database query and read out all necessary image and geolocation information into an array called rows,
	: we will assume the database has the following "columns":  id (record key), image URL hirez, image URL lorez, northBounds, southBounds, eastBounds, westBounds,
	:	rotation, drawOrder, bottomLeftLat, bottomLeftLng, bottomRightLat, bottomRightLng, topRightLat, topRightLng, topLeftLat, topLeftLng
	: must make sure all numeric "columns" contain zeros if no information (not blank)
	:
	goexMgr.startOfBulkload();
	var bounds,llQuad,GO_opts,goex,za;
	for (var i in rows) {
		if (rows[i][3] != 0 || rows[i][4] != 0 || rows[i][5] != 0 || rows[i][6] != 0) {
			neBound = new google.maps.LatLng(rows[i][3], rows[i][5]);
			swBound = new google.maps.LatLng(rows[i][4], rows[i][6]);
			bounds = new google.maps.LatLngBounds(swBound, neBound);
		} else bounds = null;
		if (rows[i][9] != 0 || rows[i][10] != 0 || rows[i][11] != 0 || rows[i][12] != 0 || rows[i][13] != 0 || rows[i][14] != 0 || rows[i][15] != 0 || rows[i][16] != 0) {
			blBound = new google.maps.LatLng(rows[i][9], rows[i][10]);
			brBound = new google.maps.LatLng(rows[i][11], rows[i][12]);
			trBound = new google.maps.LatLng(rows[i][13], rows[i][14]);
			tlBound = new google.maps.LatLng(rows[i][15], rows[i][16]);
			llQuad = new LatLngQuad(blBound, brBound, trBound, tlBound);
		} else llQuad = null;
		za = new ZoomArray();
		ze1 = new ZoomEntryZoom(0, 8, String(rows[i][2]));
		za.addZoomEntry(ze1);
		ze2 = new ZoomEntryZoom(9, 22, String(rows[i][1]));
		za.addZoomEntry(ze2);
		GO_opts = {
			id: String(rows[i][0]),
			clickable: true,
			clickableAtZoom: 4,
			clickableEvents: "dblclick",
			drawOrder: Number(rows[i][8]),
			rotate: Number(rows[i][7]),
			latlngQuad: llQuad,
			zoomArray: za
		}
		goex = new GroundOverlayEX(String(rows[i][1]), bounds, GO_opts);
		goexMgr.addGOEXbulkload(goex);
	}
	// wait 5 seconds after all that are actually visible are loaded and shown, then start preloading nearby off-screen images
	setTimeout( { goexMgr.endOfBulkload(); }, 5000);
	:
	:
}
function a_GOEX_was_doubleclicked(mouseEvent, thegoex) {
	// open an infoWindow on the GroundOverlayEX
	var infoWind = new google.maps.InfoWindow({ content: "An InfoWindow" });
	infoWind.open(map, thegoex);
}


=============================================
Using Editing in GroundOverlayEX for Map Apps
=============================================
If an application developer wants to allow in-line editing of images on their map for some reason, the GroundOverlayEX class offers mechanisms to do that. 
The first task is to ensure the application is using the proper .js library file.  To gain access to the editing features, the "GroundOverlayEXeditable.js" file
must be used.

Second the developer should choose which of the two ways they want editing mode to be initiated.
1. 	End-user control-rightclicks on a GroundOverlayEX image that has been configured as "editable: true".  An event can be listened to allow the application to know
	when editing has been initiated.
2. 	End-user invokes some application control (like a button) or mechanism (like a "properties box") that programatically activates editing of a GroundOverlayEX object. 
	There is a method the application uses to activate editing.

The third task will be whether to intercept editing changes made in-progress to show intermediate results (such as updated latitude and longitude numbers as the
GroundOverlayEX image is being moved.  The class offers events for the application to listen to.

The fourth task is to provide a means for the end-user to end editing.
1.	If the control-rightclick method of initiation was chosen, then there is an event the application can listen to get a signal when the end-user control-rightclicks 
	again to end editing.  
2.	If the application-controlled alternative was chosen, then the end-user would use the application controls to terminate editing, and there is a method the 
	application uses to end editing.

The final task is to gather the updated geolocation information after editing is completed.  
1.	If the control-rightclick method of initiation was chosen, then when the end-user performs the control-rightclick, the GroundOverlayEX class offers two ways for the application
	to know to obtain results.  One alternative is to listen for the "editing-done" event; when that event gets triggered, editing will be done - the geographic information (LatLngs and
	rotations) will be available, however the image information will have been already lost.  The second alternative is to use the EditableEndingCallback, which will get invoked midway
	through the end-of-editing shutdown; all the geographic and the image information will be available to the callback.
2.	If the application-controlled alternative was chosen, then the end-user would use the application controls to terminate editing, and the application utilizes the GroundOverlayEX
	methods to obtain the results of the edit.  Use of a listener or callback at end-of-edit should not be needed.
There are various methods the GroundOverlayEX class offers to gather the results of the editing.  Some access the geographic information, and others access the image information.

Editing Preparation Methods:				Return		Description
----------------------------				------		-----------
.supportsEditing()					Boolean		return: will always return "true" when using the GroundOverlayEXeditable.js file
.getEditable()						Boolean		return: true=potentially allow the passed parameter url image to be edited (zoomArray URLs are ignored); false=no editing allowed
.setEditable(Boolean)					Boolean		passed: true=potentially allow the passed parameter url image to be edited (zoomArray URLs are ignored); false=no editing allowed; return: true=set was successful
.setEditableForbidNonrect(Boolean:forbid)		Boolean		passed: true=do not allow the conversion of LatLngBounds-mode to LatLngQuad-mode (however those edited that are already LatLngQuad will remain so); return: true=set was successful
.setEditableEndingCallback(Function:callback)		Boolean		the callback function will get invoked at end-of-editing so the application can capture image information; the callback will be passed one parameter which is the GroundOverlayEX object that is ending its editing; return: true=callback was stored
.getDoEditing()						Boolean		return: true=activate editing of the displayed image; control-right-clicking on the image will also toggle editing
.setDoEditing(Boolean)					Boolean		passed: true=activate editing of the displayed image; control-right-clicking on the image will also toggle editing; return true=set was successful


Obtaining the results of an edit:
Baseline Geolocation Results Methods (see the main GroundOverlayEX class' definitions)
--------------------------------------------------------------------------------------
.getDisplayMode()							determining whether to get primary geo-location information from .getBounds() or .getLatLngQuad()
.getCenter()								gets the new image center latitude and longitude
.getBounds()								gets the new image non-rotated LatLngBounds; only available when in LatLngBounds-mode; will return null when in LatLngQuad-mode
.getRotation()								gets the new rotation [only applicable when in LatLngBounds-mode]
.getLatLngQuad()							gets the new LatLngQuad; this information is available in BOTH LatLngQuad-mode and LatLngBounds-mode during editing; when in LatLngBounds mode, these 
										corner latitudes and longitudes are usually quite inaccurate unless the image's camera was near perfect-vertical 
										with no tilt distortion on the image
.getLatLngQuadType()							"R"=approximate LatLngs based on the LatLngBounds-mode corners, "N"=accurate LatLngs based upon the LatLngQuad-mode corners

Image and Editing Results Methods 			Return			Description
---------------------------------			------			-----------
.editingDoRevertImage()					Boolean			Resets image back to its initial state before editing; end-user can use an alt-rightclick to trigger this as well
.setEditingAidsVisible(Number:aids,Boolean:visible)	Boolean			Aids available: 1=effective-center spot, 2=for LLQ-mode center-diagonals spot, 4=LLB-mode non-rotated image, 8=regionBounds; the indicated aids will be set shown or hidden depending on the 'visible' parameter
.getEditingIsCropped()					Boolean			true=all information is relative to the *cropped* image, false=no cropping was done
.getEditingImageInfo()					Array of Numbers	returns the following information in the array:
										[0],[1]=Original width,height; [2],[3]=Cropped fromLeft,fromBottom;
										[4],[5]=Cropped toWidth,toHeight; [6],[7]=Current width,height;
										[8],[9]=Bounds MapDiv left,top; [10],[11]=Bounds width,height;
										[12],[13]=BoundsBox MapDiv left,top; [14],[15]=BoundsBox width,height;
										[16],[17]=Current center MapDiv x,y; [18],[19]=Current diagonals MapDiv x,y;
										[20],[21]=Corner bottom-left MapDiv X,y; [22],[23]=Corner bottom-right MapDiv x,y;
										[24],[25]=Corner top-right MapDiv X,y; [26],[27]=Corner top-left MapDiv x,y;
										[28]=effective rotation
										Note: all are based upon the passed parameter url image;
										Note: Original and Cropped are non-rotated and non-transformed; 
										  Bounds is the bounds when in LatLngBounds-mode (which may be non-proportionally resized and aligns with the getBounds() method), for LatLngQuad-mode it is the hidden pre-transformed image size;
										  Current for LatLngBounds-mode is same as Box, for LatLngQuad-mode is the longest transformed widths and heights;
										  Bounds are the size of the min/max of all 4 rotated Current Image Corners x,y;
										  Current center is based upon either the rotated or transformed Current image via the intersection of the bimedians (this is aligned with the getCenter() method);
										  Diagonals center is based upon either the rotated or transformed CUrrent image via the intersection of diagonals (which for LLQ-mode images better represents the original non-transformed image's center);
										  Corners of rotated CUrrent Image are x,y relative to the origin 0,0 of the top-left of Box (this is aligned with the getLatLngQuad() method);
										  Effective rotation is either the true rotation for a LatLngBounds-mode, or a calculated effective rotation for a LatLngQuad-mode

Events during Editing notes:
	Events			Description
	------			-----------
	editing_started		editing has been initiated (either by the end-user doing a control-rightclick or by .setDoEditing(true) method)
	position_changing 	the image's center is being moved on the map (the application will get a stream of events)
	shape_changing 		the image's edges, corners, or rotation are being changed on the map (the application will get a stream of events)
	editing_done		editing has completed (either the end-user did another control-rightclick or by .setDoEditing(false) method); only geographic results are will be available
	editing_reverted	editing has been reverted back to its inital state (either the end-user using alt-rightclick or by .editingDoRevertImage() method)
Note: all the above events are provided with one passed parameter: the GOEX object that triggered the event

During the editing process, with the "clickable" passed parameter set to true, all the events will be passed, but should not be used to affect the editing 
process.  And the following additional events are triggered (the "clickable" passed parameter need not be present).  The GroundOverlayEx object is provided 
as a passed parameter.

All events are passed to the GroundOverlayEX_mgr as well, allowing the application to listen to just the manager object instead of each individual GroundOverlayEX object.


Code example:  control-rightclick initiated editing without using cropping or a ZoomArray, and using the GroundOverlayEx manager
-------------
	:
	:
	var goexMgr = new GroundOverlayEX_mgr(map);
	google.maps.event.addListener(goexMgr, "position_changing", function(theGoex) { GOEX_editing_positionChanging(theGoex); });
	google.maps.event.addListener(goexMgr, "editing_done", function(theGoex) { GOEX_editing_done(theGoex); });
	google.maps.event.addListener(goexMgr, "click", function(mouseEvt, theGOEX, imageX, imageY, lat, lon){ GOEX_editing_click(theGOEX, mouseEvt, imageX, imageY, lat, lon); });
	google.maps.event.addListener(goexMgr, "mousedown", function(mouseEvt, theGOEX, imageX, imageY, lat, lon){ GOEX_editing_mousedown(theGOEX); });
	google.maps.event.addListener(goexMgr, "mouseup", function(mouseEvt, theGOEX, imageX, imageY, lat, lon){ GOEX_editing_mouseup(theGOEX); });

	:
	: setup a database query and read out all necessary image and geolocation information into an array called rows,
	: we will assume the database has the following "columns":  id (record key), image url, northBounds, southBounds, eastBounds, westBounds, rotation, drawOrder,
	:	controlPointLat, controlPointLng, bottomLeftLat, bottomLeftLng, bottomRightLat, bottomRightLng, topRightLat, topRightLng, topLeftLat, topLeftLng
	:
	goexMgr.startOfBulkload();
	var bounds,llQuad,GO_opts,goex,controlLL;
	for (var i in rows) {
		if (rows[i][2] != 0 || rows[i][3] != 0 || rows[i][4] != 0 || rows[i][5] != 0) {
			neBound = new google.maps.LatLng(rows[i][2], rows[i][4]);
			swBound = new google.maps.LatLng(rows[i][3], rows[i][5]);
			bounds = new google.maps.LatLngBounds(swBound, neBound);
		} else bounds = null;
		if (rows[i][10] != 0 || rows[i][11] != 0 || rows[i][12] != 0 || rows[i][13] != 0 || rows[i][14] != 0 || rows[i][15] != 0 || rows[i][16] != 0 || rows[i][17] != 0) {
			blBound = new google.maps.LatLng(rows[i][10], rows[i][11]);
			brBound = new google.maps.LatLng(rows[i][12], rows[i][13]);
			trBound = new google.maps.LatLng(rows[i][14], rows[i][15]);
			tlBound = new google.maps.LatLng(rows[i][16], rows[i][17]);
			llQuad = new LatLngQuad(blBound, brBound, trBound, tlBound);
		} else llQuad = null;
		GO_opts = {
			id: rows[i][0], 
			editable: true,
			clickable: true,
			clickableEvents: "click",
			drawOrder: rows[i][7]
			rotate: rows[i][6],
			latlngQuad: llQuad
		}
		goex = new GroundOverlayEX(rows[i][1], bounds, GO_opts);
		goexMgr.addGOEXbulkload(goex);
	}
	setTimeout( function() { goexMgr.endOfBulkload(); }, 5000);
	:
	:
}
function GOEX_editing_positionChanging(theGoex) {
	// example usage: display the current centerpoint Lat,Lng as a convenience to the end-user in some HTML span with id="latlngmessagespan";
	// using .getPosition() is faster but less accurate but may be sufficient for intermediate results when "editing_done" event uses the more accurate .getCenter()
	var latlng = theGoex.getPosition();
	document.getElementById("latlngmessagespan").textContent = latlng.toString();
}
function GOEX_editing_mousedown(theGoex) {
	// example usage:  as a convenience while dragging, rotating, or resizing, set the image opacity to 50%
	theGoex.setOpacity(.5);
}
function GOEX_editing_mouseup(theGoex) {
	// example usage:  restore the opacity to 100%
	theGoex.setOpacity(1);
}
function GOEX_editing_click(theGOEX, evt, imageX, imageY, lat, lng) { 
	// (dumb) example usage: show a message about where the end-user clicked only if the shift-key was pressed during the click;
	// a far better usage would be to record a "control point" of imageX,imageY,lat,lng into a database
	if (evt.shiftkey) {
		alert("You shift-clicked on image "+theGoex.id_+" at X,Y point "+imageX+","+imageY+" which is at Lat,Lng "+lat+","+lng);
	}
}
function GOEX_editing_done(theGoex) {
	// example usage: extract a set of geolocation information from the now updated GroundOverlayEX object and store the results in some database
	// remember, only geographic/rotation results are available for the "editing_done" event alternative
	var llb,llq = null;
	var rotate = 0;
	if (theGoex.getDisplayMode() == "B") {
		llb = theGoex.getBounds();
		rotate = theGoex.getRotation();
	} else {
		llq = theGoex.getLatLngQuad();
	}

	var centerLatLng = theGoex.getCenter();
	document.getElementById("latlngmessagespan").textContent = centerLatLng.toString();

	:
	: code to store all this new information into a database, using theGoex.id_ as the key to locate the proper record to update
	:
}


=========================================================
Using Editing in GroundOverlayEX for GeoLocation Web-apps
=========================================================
An application developer can use this class within a Geolocation web-app.  This type of web-app would allow display of non-geolocated images such that the end-user positions and 
sizes the image over a map to create the geolocation information.  Or to adjust images that have existing geolocation information.  Normally only one image (and thus just one object instance
of the GroundOverlayEX class) would be shown on the web-app.

All the information presented in the prior section on editing in a map display app are applicable to a geolocation app.

To support a geolocation web-app, some additional methods are provided:

Editing Preparation Methods:						Return			Description
----------------------------						------			-----------
.setEditableImageLoadedCallback(Function:callback)			Boolean			the callback function will get invoked when the to-be-edited image has successfully loaded; the callback will be passed one parameter which is the GroundOverlayEX object that has completed the load; return: true=callback was stored
.getEditableIsImageLoaded()						Boolean			true=image has loaded, false=image has not yet downloaded
.editableLoadAllImages()						Boolean			forces the download of all images in the passed ZoomArray (such that they can be used to get information about the sub-images in later calls); true=loads were initiated
.setEditableInitialLLBSizeAndPosition(Number:imageWidth, Number:imageHeight, Boolean:sizesAreMax, google.maps.LatLng:initialLatLng, Number:initialImageX, Number:initialImageY)
									Boolean			This method allows the application to display a non-geolocated image (that does not yet have a Bounds or a LatLngQuad);
												The image is sized as specified in the passed parameters: 
												    if sizesAreMax=false then the image is set to the exact sizes of passed parameters imageWidth and imageHeight;
												    if sizesAreMax=true then whichever of the image's width are height are smaller is set of the appropriate passed value, and the other axis is proportionally resized to maintain the aspect ratio
												The map is panned to the InitialLatLng value.
												Then the image is placed at the InitialLatLng value:
													if both initialImageX and initialImageY are >= 0 and on the image's original-image-size, then the image coordinate {initialImageX,initialImageY} is placed at initialLatLng
													otherwise or if initialImageX and initialImageY are both -1, then the image's center is placed at InitialLatLng

Editing Image Manipulation Methods:
------------------------------------
.setEditingPinImageToMap(Boolean:pinToMap)				Boolean			pinToMap=true then dragging of the image on the map is turned off such that dragging the image drags the entire map; pinToMap=false then the image drags separately from the map
.editingGotoImageCenterToLatLng(google.maps.LatLng:moveToLatLng)	Boolean			the image's center is panned on the map to the indicated LatLng coordinates; true=panning was performed
.setEditingRotation(Number:rotation)					Boolean			the LLB-mode only image's rotation is changed to the passed value; true=rotation was changed
.setEditingDeltaImageResizing(Number:WidthPixelsToResize, Number:heightPixelsToResize)		the LLB-mode only image's width and height are separately incremented (+ numbers) or decremented (- numbers) by the indicated pixels; can be used for non-proportional resizing
.setEditingDeltaImageProportionalResizing(Number:pixelsToResize)	Boolean			the LLB-mode only image's width and height are simultaneously proportionally resized; whichever of width or height are SMALLER gets the passed number of pixels added (+ number) 
												or subtracted (- number), the other (longer) axis gets a proportionally larger increase/decrease that maintains the aspect ratio of the image
Editing Results Methods:
------------------------
.getEditingCropResults_ZoomArray(Number:zoomArrayIndex)			Array of Numbers	returns cropping information proportionally resized for the selected image in the ZoomArray; [0]=cropFromLeft, [1]=cropFromBottom, [2]=cropToWidth, [3]=cropToHeight
.getEditingCurrImagePointFromLatLng(google.maps.LatLng:LatLngToLocate)	Array of Numbers	given the passed LatLng, its position on the current transformed image is calculated in original-image-sized X,Y coordinates; if the passed LatLng is off the image then null is returned
.getEditingCurrImageLatLngFromImagePoint(Number:imageX, Number:imageY)	google.maps.LatLng	given the passed original-image-sized X,Y coordinates, the corresponding LatLng is calculated on the transformed image; if the X,Y coordinates are off the original-image-size then null is returned



Initializing and Loading images to-be-edited in a geolocation web-app is a bit more complex than the example code shown for a display map editing capability.  
Due to the various asynchronous natures of map loading, image loading, and image displaying, more use of callbacks and one-time listeners are required for bug-free operation.
And there may be numerous external controls used to manipulate the image in addition to using mouse-editing.  Additional mouse controls (such as the scroll wheel) might also be desired
to be used for editing purposes (rather than just map zooming).  Since this class has been implemented in at least one Geolocation web-app, all these features are possible with the
existing class.


Code example for only non-geolocated images:  	
============================================		
This code is not a fully workable example, but shows various snippets of what needs to be accomplished. 
There are many other ways to setup a geolocation web-app tool, including one web-app that can edit both geolocated and nongeolocated images.
In this example, 
a. the end-user enters in limited information known about the image (at least its URL and some initial LatLng), then presses the "Load Image" button.
b. then they manipulate the image with both mouse controls and some screen controls.
c. the end-user does not "end editing", but rather pushes a "Get Results" button to get the results of the editing.
d. then the end-user enters new data for the next image and presses the "Load Image" button again.


HTML - example only - this would look terrible on a real browser window
====
<body onload="initPage()">

<div id="map_canvas" style="border: 1px solid white; position: relative;"></div>

<div id="controls">
<button id="controls_CenterButton" type="button" onclick="GotoMapAndImageToCenter()" style="width:105px">Recenter</button>
<button id="controls_ImagePinButton" type="button" onclick="TogglePinning()" style="width:105px">Unpinned</button>
<button id="controls_GrowButton" type="button" onclick="ResizeImageProportional(10)" style="width:105px">Grow</button>
<button id="controls_ShrinkButton" type="button" onclick="ResizeImageProportional(-10)" style="width:105px">Shrink</button>
<button id="controls_RevertButton" type="button" onclick="RevertImage()" style="width:105px">Revert Image</button><br>
Base opacity: <input type="range" name="controls_baseOpacity" id="controls_baseOpacity" onInput="AdjustTransparency()" onChange="AdjustTransparency()" min="0" max="10" step=".1" value="10" style="width:200px">
</div>

<div id="inputs">
Image URL: <input name="input_ImageURL" id="input_imageURL" size="100" maxlength="1024"><br>
Image Center LL: <input name="input_Lat_center" id="input_Lat_center" size="10" maxlength="10">, <input name="input_Lon_center" id="input_Lon_center" size="10" maxlength="10"><br>
Controlpoint LL: <input name="input_Lat_control" id="input_Lat_control" size="10" maxlength="10">, <input name="input_Lon_control" id="photoID_Lon_maincity" size="10" maxlength="10"><br>
CropFrom Left,Bottom: <input name="input_CropX" id="input_CropX" size="6" maxlength="10" value="0">, <input name="input_CropY" id="input_CropY" size="6" maxlength="10" value="0"><br>
CropTo Width,Height: <input name="input_CropWidth" id="input_CropWidth" size="6" maxlength="10" value="0">, <input name="input_CropHeight" id="input_CropHeight" size="6" maxlength="10" value="0"><br>
Rotate: <input name="input_Rotate" id="input_Rotate" size="6" maxlength="10" value="0"><br>
MapZoom: <input name="input_MapZoom" id="input_MapZoom" size="2" maxlength="2" value="0"><br>
<button id="input_LoadImage" type="button" onclick="LoadImage()" style="width:105px">Load Image</button>
</div>

<div id="results">
<button id="results_getButton" type="button" onclick="GetResultsButton()" style="width:105px">Get Results</button><br>
<span id="results1"></span><br>
<span id="results2"></span>
</div>
</body>


Javascript - note that of course Google Maps API V3 javascript library must be loaded, as well as the Numeric library, and of course the GroundOverlayEXeditable library
==========
var map = null;
var goex = null;
var InitialLL = null;
var ControlLL = null;
var Marker = null;
var PinImageToMap = false;
var BaseOpacity = 10;
var Listener1 = null;
var Listener2 = null;
var Listener3 = null;

// initialize functions upon page being fully loaded
function initPage() {
	var initialLatLng=new google.maps.LatLng(20,0);	// or where-ever; this will get panned once an image is loaded

	// use whichever map options the app developer desires, the below are just examples
	var mapOptions={
		zoom: 3,
		center: initialLatLng,
		mapTypeId: google.maps.MapTypeId.HYBRID,
		navigationControl: true,
		mapTypeControl: true,
		rotateControl: true,
		scaleControl: true,
		zoomControl: true,
		scrollwheel: false,			// prevents scroll-wheel from map zooming; maybe want to do this or not, or give the end-user a button to choose for themselves
		disableDoubleClickZoom: true };		// prevents double-click on map from zooming-in which can be annoying for a geolocation web-app
	map = new google.maps.Map(document.getElementById("map_canvas"), mapOptions);
	//google.maps.event.addListenerOnce(map, 'tilesloaded', mapReady);	// this can be used if some post-map-initialized logic is needed
}

// the end-user has filled in appropriate input fields and wants to load an image
function loadImage() {
	// load image stage 1

	: there should be code here to validate all the input fields before doing anything, and presenting alerts for bad inputs
	: at a minimum, the input_ImageURL, input_Lat_center, and input_Lon_center fields must have valid values
	: assume a function-local variable has been created for each validated input field with the same name

	// save the control LatLng for later in a global variable
	if (ControlLL != null) { ControlLL = null; }	// force a garbage-collection since this function needs to be re-entrant
	if (input_Lat_control != 0 && input_Lon_control != 0) ControlLL = new google.maps.LatLng(input_Lat_control, input_Lon_control);

	if (input_MapZoom == 0) map.setZoom(11);	// this map zoom default is arbitrary; use whatever seems appropriate
	else map.setZoom(input_MapZoom);

	if (InitialLL != null) { InitialLL = null; }	// force a garbage-collection since this function needs to be re-entrant
	InitialLL = new google.maps.LatLng(input_Lat_center, input_Lon_center);
	map.panTo(InitialLL);

	// construct the GroundOverlayEX options					
	var GO_opts = {
		editable: true,
		clickable: true,
		cropFromLeft: input_CropX,
		cropFromBottom: input_CropY,
		cropToWidth: input_CropWidth,
		cropToHeight: input_CropHeight,
		rotate: input_Rotate
	}

	// remember this function needs to be re-entrant; the user may be editing numerous images during a session; always do clean-up activities to avoid memory leaks
	if (goex != null) { goex.destroy(); goex = null; }	
	
	// create the GroundOverlayEX object, record a callback, load it onto the map, and set the one-time listener
	goex = new GroundOverlayEX(input_ImageURL, null, GO_opts);
	goex.setEditableImageLoadedCallback( function(theGOEX){imageFinallyLoaded(theGOEX);} );
	goex.setMap(map);
	google.maps.event.addListenerOnce(goex, "editing_started", function(theGOEX){imageFinallyDisplayedForEditing(theGOEX);});

	// perform some other initialization tasks to allow map to pan and image load to complete
	// example: place a marker onto the map of the control point if specified in the inputs
	if (ControlLL != null) {
		if (Marker != null) {
			// remember this function needs to be re-entrant; the user may be editing numerous images during a session; always do clean-up activities to avoid memory leaks
			Marker.setMap(null);
			Marker = null;
		}	
		Marker = new google.maps.Marker({
    			position: ControlLL,
    			icon: {
      				path: google.maps.SymbolPath.CIRCLE,
      				scale: 4,
				fillColor: '#00ff00',
				strokeColor: '#00ff00' },
    			draggable: false,
    			map: map });
	}

	// add selected DOM event listeners; again don't forget about re-entrance and garbage collection
	if (Listener1 != null) {google.maps.event.removeListener(Listener1); Listener1 = null; }
	if (Listener2 != null) {google.maps.event.removeListener(Listener2); Listener2 = null; }
	if (Listener3 != null) {google.maps.event.removeListener(Listener3); Listener3 = null; }
	Listener1 = google.maps.event.addListener(goex, "mousedown", function(mouseEvt, theGOEX, imageX, imageY, lat, lon){GOEX_editing_mousedown();} );
	Listener2 = google.maps.event.addListener(goex, "mouseup", function(mouseEvt, theGOEX, imageX, imageY, lat, lon){GOEX_editing_mouseup();} );
	Listener3 = google.maps.event.addListener(goex, "mouseout", function(mouseEvt, theGOEX, imageX, imageY, lat, lon){GOEX_editing_mouseout();} );
}

function imageFinallyLoaded(theGOEX) {
	// load image stage 2
	// the below code will set the image's size to 1/4 the size of the map window
	// then it will place that smaller sized image's center at the center LatLng specified by the end-user;
	// if a rotation has been pre-defined in the GO_opts then rotation will also be performed last
	var mapCanvas = document.getElementById("map_canvas");
	var mWidth = mapCanvas.width(); 
	var mHeight = mapCanvas.height();
	theGOEX.setEditableInitialLLBSizeAndPosition(mWidth * .25, mHeight * .25, true, InitialLL, -1, -1);

	// begin the editing process in order to activate all the editing-only methods;
	// this will auto-map and auto-display the image as well if such as not yet been done;
	// however there will be a delay due to Google Maps callbacks we have to rely upon the "editing_started" event to finalize the initialization process
	theGOEX.setDoEditing(true);
}

function imageFinallyDisplayedForEditing(theGoex) {
	// load image stage 3 - final
	// the image is now showing and is editable;
	// show all the editing aids (though normally this is likely more than is needed; usually it would just be the bimedians centerspot)
	// aids binary values: 1=true center (LLB&LLQ), 2=diagonal center (LLQ-only), 4=bounds (LLB-only), 8=regionBounds (LLB&LLQ)
	theGoex.setEditingAidsVisible(15, true);

	// the below will actually toggle-off pin-to-map, then set the opacity to whatever the slider is presently indicating
	PinImageToMap = true;
	TogglePinning();
	AdjustTransparency();
}

// respond to buttons and controls invoked by the end-user
function GotoMapAndImageToCenter() {
	// force the map and the image back to the initial center LatLng
	map.panTo(InitialLL);
	if (goex != null) goex.editingGotoImageCenterToLatLng(InitialLL);
}

function AdjustTransparency() {
	// adjust the baseline transparency of the image
	BaseOpacity = Number(document.getElementById("controls_baseOpacity").value) / 10;
	if (goex != null) goex.setOpacity(BaseOpacity);
}

function TogglePinning() {
	// toggle whether to pin the image to the map or not
	if (PinImageToMap) {
		PinImageToMap = false;
		document.getElementById("controls_ImagePinButton").text("Unpinned");
		if (goex != null) goex.setEditingPinImageToMap(false);
		
	} else {
		PinImageToMap = true;
		document.getElementById("controls_ImagePinButton").text("Pinned");
		if (goex != null) goex.setEditingPinImageToMap(true);
	}
}

function RevertImageButton() {
	// revert the image back to its initial state
	if (goex != null) goex.editingDoRevertImage();
}

function ResizeImageProportional(pValue) {
	if (goex != null) goex.setEditingDeltaImageProportionalResizing(pValue);
}

// respond to selected DOM events
function GOEX_editing_mousedown() {
	// make the image more transparent during editing functions
	if (!PinImageToMap) goex.setOpacity(BaseOpacity * .5);
}

function GOEX_editing_mouseup() {
	// restore the end-user set base opacity
	goex.setOpacity(BaseOpacity);
}

function GOEX_editing_mouseout() {
	// restore the end-user set base opacity
	goex.setOpacity(BaseOpacity);
}

function GetResultsButton() {
	if (goex == null) return;

	var results1 = "Geolocation results: "
	var centerLL = goex.getCenter();
	results1 += "CenterLL="+centerLL.toString()+"; ";

	if (ControlLL != null) {
		var iPos = goex.getEditingCurrImagePointFromLatLng(ControlLL);
		if (iPos != null)  results1 += "ControlLL="+iPos[0].toFixed(0)+","+iPos[1].toFixed(0)+"; ";
		else  results1 += "ControlLL={offimg}; ";
		iPos = null;
	}

	var bounds = goex.getBounds();
	if (bounds != null) {
		results1 += "Bounds="+bounds.toString()+"; ";
		bounds = null;
	} else {
		 results1 += "Bounds={none}; ";
	}

	var rot = goex.getRotation();
	results1 += "KML Rotation CCW="+rot.toFixed(1)+"; ";
	
	var llq = goex.getLatLngQuad();
	if (llq != null) {
		if (goex.getLatLngQuadType() == "N") results1 += "QuadNonrect="
		else if (goex.getLatLngQuadType() == "R") results1 += "QuadRect="
		else results1 += "Quad="
		results1 += llq.toString()+"; ";
		llq = null
	} else {
		 results1 += "Quad={none}; ";
	}

	// [0],[1]=Original width,height; [2],[3]=Cropped fromLeft,fromBottom;
	// [4],[5]=Cropped toWidth,toHeight; [6],[7]=Current width,height;
	// [8],[9]=Bounds MapDiv left,top; [10],[11]=Bounds width,height;
	// [12],[13]=BoundsBox MapDiv left,top; [14],[15]=BoundsBox width,height;
	// [16],[17]=Current center Img x,y; [18],[19]=Current diagonals Img x,y;
	// [20],[21]=Current center MapDiv x,y; [22],[23]=Current diagonals MapDiv x,y;
	// [24],[25]=Corner bottom-left MapDiv X,y; [26],[27]=Corner bottom-right MapDiv x,y;
	// [28],[29]=Corner top-right MapDiv X,y; [30],[31]=Corner top-left MapDiv x,y
	// [32] = effective/approximate rotation (deg clockwise)
	var imageInfo = goex.getEditingImageInfo();

	var results2 = "Image results: "
	results2 += "Orig W,H="+imageInfo[0].toFixed(0)+","+imageInfo[1].toFixed(0)+"; ";
	results2 += "Crop Img left,bottom="+imageInfo[2].toFixed(0)+","+imageInfo[3].toFixed(0)+"; ";
	results2 += "Crop W,H="+imageInfo[4].toFixed(0)+","+imageInfo[5].toFixed(0)+"; ";
	results2 += "Curr W,H="+imageInfo[6].toFixed(0)+","+imageInfo[7].toFixed(0)+"; ";
	results2 += "Center Img X,Y="+imageInfo[16].toFixed(0)+","+imageInfo[17].toFixed(0)+"; ";
	results2 += "HTML rotation CW="+imageInfo[32].toFixed(1)+"; ";
	imageInfo = null;
	
	document.getElementById("results1").text(results1);
	document.getElementById("results2").text(results2);
}
